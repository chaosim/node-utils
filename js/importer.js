/***************************************************************************
 #Author   : Caoxingming
 #Email    : simeon.chaos@gmail.com
 #Homepage : https://github.com/chaosim
 #Source   : https://github.com/chaosim
 #License  : Simplified BSD License
 #Version  : 0.1.0
 #
 #Copyright 2013 Caoxingming. All rights reserved.
 #
 #Redistribution and use in source and binary forms, with or without
 #modification, are permitted provided that the following conditions are met:
 #
 #1. Redistributions of source code must retain the above copyright notice,
 #this list of conditions and the following disclaimer.
 #
 #2. Redistributions in binary form must reproduce the above copyright notice,
 #this list of conditions and the following disclaimer in the documentation
 #and/or other materials provided with the distribution.
 #
 #THIS SOFTWARE IS PROVIDED BY CAOXINGMING 'AS IS' AND ANY EXPRESS OR IMPLIED
 #WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 #MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 #EVENT SHALL CAOXINGMING OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 #INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 #LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 #PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 #LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 #OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 #ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #The views and conclusions contained in the software and documentation are those
 #of the authors and should not be interpreted as representing official policies,
 #either expressed or implied, of Joey Mazzarelli.
 #***************************************************************************/

/***************************************************************************
// usage: copy this file to your project, and then in your .coffee file:

I = require("imorter")

I.use("underscore: isString, isArray")
I.at("underscore.first, underscore.last")
I.all("underscore and_other_module_path")

underscore = require("underscore")

I.with_(underscore, " isString some", function() {
    test.ok(isString(''));
    test.ok(some([3, 2], function(x) {
      return x > 1;
    }));
    test.throws(function() {
      return first([3, 2]);
    });
    return test.done();
  });

 I.with_(underscore, function() {
        test.ok(isString(''));
        test.ok(some([3, 2], function(x) {
          return x > 1;
        }));
        return test.equal(first([3, 2]), 3);
      });

 # SEE test/test_importer.js for more information
 #***************************************************************************/

// Generated by CoffeeScript 1.6.2


(function() {
  var path_namesSplit, reElements, split;

  exports.version = '0.1.0';
  exports.comman_space_splitter = reElements = /\s*,\s*|\s+/;

  path_namesSplit = /:[ \t]+/;

  exports.split = split = function(str, sep) {
    var x, _i, _len, _ref, _results;

    _ref = str.split(sep);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      if (x) {
        _results.push(x);
      }
    }
    return _results;
  };

  exports.all = function(path_list) {
    var modu, name, path, value, _i, _len, _ref, _results;

    _ref = split(path_list, reElements);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      path = _ref[_i];
      modu = require(path);
      _results.push((function() {
        var _results1;

        _results1 = [];
        for (name in modu) {
          value = modu[name];
          _results1.push(global[name] = value);
        }
        return _results1;
      })());
    }
    return _results;
  };

  exports.from = function(path_names) {
    var modu, name, names, path, _i, _len, _ref, _ref1, _results;

    _ref = split(path_names, path_namesSplit), path = _ref[0], names = _ref[1];
    modu = require(path);
    _ref1 = split(names, reElements);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      name = _ref1[_i];
      _results.push(modu[name]);
    }
    return _results;
  };

  exports.use = function(path_names) {
    var modu, name, names, path, _i, _len, _ref, _ref1, _results;

    _ref = split(path_names, path_namesSplit), path = _ref[0], names = _ref[1];
    modu = require(path);
    _ref1 = split(names, reElements);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      name = _ref1[_i];
      _results.push(global[name] = modu[name]);
    }
    return _results;
  };

  exports.at = function(path_list) {
    var item, path, _i, _len, _ref, _ref1, _results;

    _ref = split(path_list, /\s*,\s*/);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      path = _ref[_i];
      _ref1 = path.split('.'), path = _ref1[0], item = _ref1[1];
      _results.push(global[item] = require(path)[item]);
    }
    return _results;
  };

  exports.with_ = function(obj, fun, names) {
    var name, result, saved_global, v, _i, _len, _ref;

    saved_global = {};
    if (names) {
      _ref = [fun, names], names = _ref[0], fun = _ref[1];
      names = split(names, reElements);
    } else {
      names = (function() {
        var _results;

        _results = [];
        for (name in obj) {
          _results.push(name);
        }
        return _results;
      })();
    }
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      if (global[name] !== void 0) {
        saved_global[name] = global[name];
      }
      global[name] = obj[name];
    }
    result = fun();
    for (name in saved_global) {
      v = saved_global[name];
      global[name] = v;
    }
    return result;
  };

  exports.set_global = function(obj, names) {
    var name, saved_global, _i, _len;

    saved_global = {};
    names = names ? split(names, reElements) : (function() {
      var _results;

      _results = [];
      for (name in obj) {
        _results.push(name);
      }
      return _results;
    })();
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      saved_global[name] = global[name];
      global[name] = obj[name];
    }
    return saved_global;
  };

}).call(this);

/*
//@ sourceMappingURL=utils.map
*/
